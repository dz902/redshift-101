# 查询调优

- 在开始下面步骤之前，执行下面这条语句来关闭缓存，这样你就能知道真实的请求情况。

```
ALTER USER [Your-Redshift_User] SET enable_result_cache_for_session TO false;
```


## 选择性过滤

Redshift 在查询时可以使用索引进行加速。我们在载入数据时设置了 `ORDERKEY (o_orderdate)`，针对该索引字段做条件查询时，效率会更高。

下面这个查询是针对索引的。

```
SELECT count(1), sum(o_totalprice)
FROM orders
WHERE o_orderdate between '1992-07-05' and '1992-07-07';
```

下面这个则不是。

```
SELECT count(1), sum(o_totalprice)
FROM orders
where o_orderkey < 600001;
```

二者扫描的数据量类似，但效率差别很大。通过下面这个语句可以查看两个语句的实际执行时间。

```
SELECT query, TRIM(querytxt) as SQL, starttime, endtime, DATEDIFF(microsecs, starttime, endtime) AS duration
FROM STL_QUERY
WHERE TRIM(querytxt) LIKE '%orders%'
ORDER BY starttime DESC
LIMIT 4;
```

其中的 `duration` 展示了两个语句的执行时间差异，单位为微妙。

- ❗️如果你的集群配置不高则会很明显，如果配置高则差异不明显。


## 数据压缩

Redshift 使用列式存储，并且会针对列中的数据进行压缩以高效地读取和统计数据。

使用下面的语句可以查看某个表的所有列的压缩算法。

```
SELECT tablename, "column", encoding
FROM pg_table_def
WHERE schemaname = 'public' AND tablename = 'lineitem'
```

这个表的数据导入时，我们让 Redshift 自动按数据类型选择了算法。

下面我们测试下如果没有压缩的效果。用下面的语句创建一个新的 `lineitem` 表，然后使用原始格式（`RAW`）存储不做压缩。

```
DROP TABLE IF EXISTS lineitem_v1;
CREATE TABLE lineitem_v1 (
  L_ORDERKEY bigint NOT NULL ENCODE RAW       ,
  L_PARTKEY bigint ENCODE RAW                 ,
  L_SUPPKEY bigint ENCODE RAW                 ,
  L_LINENUMBER integer NOT NULL ENCODE RAW    ,
  L_QUANTITY decimal(18,4) ENCODE RAW         ,
  L_EXTENDEDPRICE decimal(18,4) ENCODE RAW    ,
  L_DISCOUNT decimal(18,4) ENCODE RAW         ,
  L_TAX decimal(18,4) ENCODE RAW              ,
  L_RETURNFLAG varchar(1) ENCODE RAW          ,
  L_LINESTATUS varchar(1) ENCODE RAW          ,
  L_SHIPDATE date ENCODE RAW                  ,
  L_COMMITDATE date ENCODE RAW                ,
  L_RECEIPTDATE date ENCODE RAW               ,
  L_SHIPINSTRUCT varchar(25) ENCODE RAW       ,
  L_SHIPMODE varchar(10) ENCODE RAW           ,
  L_COMMENT varchar(44) ENCODE RAW
)
DISTKEY (L_ORDERKEY)
SORTKEY (L_RECEIPTDATE);

INSERT INTO lineitem_v1
SELECT * FROM lineitem;

ANALYZE lineitem_v1;
```

- ❗️这个操作比较耗时。

使用下面的语句来对比两个表的存储空间。

```
SELECT
  CAST(d.attname AS CHAR(50)),
  SUM(CASE WHEN CAST(d.relname AS CHAR(50)) = 'lineitem'
THEN b.size_in_mb ELSE 0 END) AS size_in_mb,
  SUM(CASE WHEN CAST(d.relname AS CHAR(50)) = 'lineitem_v1'
THEN b.size_in_mb ELSE 0 END) AS size_in_mb_v1,
  SUM(SUM(CASE WHEN CAST(d.relname AS CHAR(50)) = 'lineitem'
THEN b.size_in_mb ELSE 0 END)) OVER () AS total_mb,
  SUM(SUM(CASE WHEN CAST(d.relname AS CHAR(50)) = 'lineitem_v1'
THEN b.size_in_mb ELSE 0 END)) OVER () AS total_mb_v1
FROM (
  SELECT relname, attname, attnum - 1 AS colid
  FROM pg_class t
  INNER JOIN pg_attribute a ON a.attrelid = t.oid
  WHERE t.relname LIKE 'lineitem%') d
INNER JOIN (
  SELECT name, col, MAX(blocknum) AS size_in_mb
  FROM stv_blocklist b
  INNER JOIN stv_tbl_perm p ON b.tbl=p.id
  GROUP BY name, col) b
ON d.relname = b.name AND d.colid = b.col
GROUP BY d.attname
ORDER BY d.attname;
```

其中：

- `size_in_mb` = 某个表的大小
- `total_mb` = 整个数据库的大小














